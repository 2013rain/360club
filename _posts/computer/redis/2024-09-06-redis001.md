---
title: redis - 安装与使用
date: 2024-09-06 12:00:00 +0800
categories: ["存储", "redis"]
tags: ["redis"]
author: wangfuyu
math: true 
img_path: /static/image/

---

## redis 安装与使用

### 下载安装

> redis中文网
>
> https://www.redis.net.cn/
>
> 参考地址：
>
> https://www.redis.net.cn/tutorial/3503.html

 

```bash
#下载地址

wget http://download.redis.io/releases/redis-5.0.4.tar.gz

tar -xvf redis-5.0.4.tar.gz

cd redis-5.0.4

yum install gcc g++

# 如果make错误用 make MALLOC=libc
make  

./redis-server redis.conf

# 客户端cmd
./redis-cli -h 127.0.0.1

```





### 数据类型的使用

> 字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。

#### （7-1）String - 字符串

> 1. string是redis**最基本的类型**，你可以理解成与Memcached一模一样的类型，一个key对应一个value。
> 2. string类型是**二进制安全的**。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。
> 3. string类型一个键（key）最大能存储512MB。
>
> 

```bash
[wangfuyu@wfy ~]$ redis-cli
# 设置缓存
127.0.0.1:6379> set key value [NX|XX] [GET] [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|KEEPTTL]

# 读取缓存内容
127.0.0.1:6379> get key

# 获取字符串的长度
127.0.0.1:6379> strlen key

# 获取字符串的长度
127.0.0.1:6379> strlen key

# 自增|自减 
127.0.0.1:6379> incr|decr key
127.0.0.1:6379> incrby|decrby key increment

# 在原来的值后面追加新内容
127.0.0.1:6379> append key value

# 防止重复设置，可用于锁
127.0.0.1:6379> setnx key value

# 在key的下标offset位置开始用value覆盖旧值，有则覆盖
127.0.0.1:6379> setrange key offset value

127.0.0.1:6379> getrange key start end

# 获取旧值，写入新值
127.0.0.1:6379> getset key value



```



#### （7-2）Hash - 哈希

> 1. Redis hash 是一个键值对集合。
>
> 2. Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。
>
> 3. 每个 hash 可以存储 2^32^ - 1 键值对（40多亿）。
>
>    

```bash
# 设置field和value
127.0.0.1:6379> hset key field value [field value ...]

# 读取field内容
127.0.0.1:6379> hget key field

# 读取当前key下所有的field和value
127.0.0.1:6379> hgetall key

# 并发锁方式初始化值
127.0.0.1:6379> hsetnx key field value

# 累计值+increment
127.0.0.1:6379> hincrby key field increment

# 查看field是否在哈希表key中
127.0.0.1:6379> hexists key field

# 删除fields
127.0.0.1:6379> hdel key field [field ...]

# 获取哈希表的 所有键、值
127.0.0.1:6379> hkeys key
127.0.0.1:6379> hvals key
```



#### （7-3）List - 列表

> 1. Redis 列表是简单的字符串列表，按照插入顺序排序。
>
> 2. 可以添加一个元素导列表的头部（左边lpush）或者尾部（右边rpush）。
>
> 3. 列表最多可存储 2^32^ - 1 元素（每个列表可存储40多亿）。
>



```bash
# 头部添加多个元素
127.0.0.1:6379> lpush key element [element ...]

#  头部(左侧)弹出一个值或者count个
127.0.0.1:6379> lpop key [count]


# 尾部添加多个元素
127.0.0.1:6379> rpush key element [element ...]

# 右侧弹出一个值或者count个
127.0.0.1:6379> rpop key [count]


# 这个命令会先从 source 列表中移除最后一个元素，然后将这个元素插入到 destination 列表的最后面，并返回这个元素的值。
127.0.0.1:6379> rpoplpush source destination

# 按照索引下标 获得元素，（从左到右）
127.0.0.1:6379> lrange key start stop

# 列表长度
127.0.0.1:6379> llen key

# 在pivot的前|后 插入 element元素
127.0.0.1:6379> linsert key BEFORE|AFTER pivot element


# 按照索引index获取元素
127.0.0.1:6379> lindex key index

# 从左侧删除count个element值（用于删除重复值）
127.0.0.1:6379> lrem key count element

# 列表下标index的值替换成 element
127.0.0.1:6379> lset key index element
```





#### （7-4）Set - 集合

>1. Redis的Set是string类型的无序集合。
>2. 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。
>3. 集合中最大的成员数为 2^32^ - 1 成员（ 每个集合可存储40多亿个成员）。

```bash
# 添加成员
127.0.0.1:6379> sadd key member [member ...]

# 查看集合中的成员
127.0.0.1:6379> smembers key

# 判断集合中是否存在该值
127.0.0.1:6379> sismember key member

# 集合中成员个数
127.0.0.1:6379> scard key

# 删除集合中的元素
127.0.0.1:6379> srem key member [member ...]

# 随机弹出1个（count个）元素
127.0.0.1:6379> spop key [count]

# 随机从该集合取出1个（count个）值，不删除，count大于总个数，则全部返回
127.0.0.1:6379> srandmember key [count]

# 讲一个值member从一个集合source移动到另一个集合destination
127.0.0.1:6379> smove source destination member

# 多个集合的交集
127.0.0.1:6379> sinter key [key ...]

# 多个集合并集
127.0.0.1:6379> sunion key [key ...]

# 差集
127.0.0.1:6379> sdiff key [key ...]
```



#### （7-5）zset - 有序集合

> sorted set
>
> 1. zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。
> 2. 每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。
> 3. zset的成员是唯一的,但分数(score)却可以重复。
>
> 

```bash
# 将元素member以及对应的score加入到有序集合
127.0.0.1:6379> zadd key [NX|XX] [GT|LT] [CH] [INCR] score member [score member ...]

# 返回有序集合中下标从start到stop之间的得分和元素，添加withscores 连分数和值一起返回
127.0.0.1:6379> zrange key start stop [BYSCORE|BYLEX] [REV] [LIMIT offset count] [WITHSCORES]

# 返回有序集合中下标从start到stop之间的得分和元素，倒序，添加withscores 连分数和值一起返回
127.0.0.1:6379> zrevrange key start stop [WITHSCORES]

# 有序集合成员数
127.0.0.1:6379> zcard key

# 计算有序集合中指定区间分株的成员数
127.0.0.1:6379> zcount key min max

# 删除成员
127.0.0.1:6379> zrem key member [member ...]

# 有序集合中指定成员的索引
127.0.0.1:6379> zrank key member

# 有序集合中成员的分数值
127.0.0.1:6379> zscore key member

# 有序集合中计算指定字典区间内成员数量
127.0.0.1:6379> zlexcount key min max

# 返回有许集合中所有score值界在minhe max之间[min,max],成员按照score从小到大。
127.0.0.1:6379> zrangebyscore key min max [WITHSCORES] [LIMIT offset count]

# 返回有许集合中所有score值界在minhe max之间[min,max],成员按照score从大到小。倒序。
127.0.0.1:6379> zrevrangebyscore key max min [WITHSCORES] [LIMIT offset count]

# 有序集合中，指定成员member的分数进行自增+increment
127.0.0.1:6379> zincrby key increment member

# 计算给定的一个或者多个有序集合的交集并将结果集存储在新的有序集合destination
127.0.0.1:6379> zinterstore destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]

# 移除有序集合中给定的分数区间的所有成员
127.0.0.1:6379> zremrangebyscore key min max
```





#### （7-6）bitmap - 位图

>1. Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。
>2. Bitmap是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。
>3. BitMap通过最小的单位bit来进行`0|1`的设置，表示某个元素的值或者状态，时间复杂度为O(1)。
>4. 他可以极大的节约存储空间，使用512M内存就可以存储多达42.9亿的字节信息(2^32^ = 4294967296)

```bash
# 设置位图中特定偏移量offset处的位值value
127.0.0.1:6379> setbit key offset value

# 获取指定键位图中，特定偏移量offset位置的位值，offset偏移量从0开始
127.0.0.1:6379> getbit key offset

# 位图中，从start偏移量到end偏移量之间的所有位的数量
127.0.0.1:6379> bitcount key [start end [BYTE|BIT]]

# 多个位图执行位操作operation（AND 按位与 | OR 按位或 | XOR 按位异或 | NOT 按位非），将结果存储到destkey中
127.0.0.1:6379> bitop operation destkey key [key ...]

# 返回指定位图指定的位置，若没有对应位，则返回-1
127.0.0.1:6379> bitpos key bit [start [end [BYTE|BIT]]]
```



#### （7-6）HyperLogLog - 基数统计



什么是基数?
比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。

```bash
# 添加指定元素到 HyperLogLog 中。
127.0.0.1:6379> pfadd key [element [element ...]]


# 返回给定 HyperLogLog 的基数估算值。
127.0.0.1:6379> pfcount key [key ...]


# 将多个 HyperLogLog 合并为一个 HyperLogLog到destkey
127.0.0.1:6379> pfmerge destkey sourcekey [sourcekey ...]
```






### 其他用法

#### 发布与订阅

> 1. Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。
> 2. Redis 客户端可以订阅任意数量的频道channel。
> 3. 



```bash
# 订阅频道channel，接收消息
127.0.0.1:6379> subscribe channel [channel ...]

#。。。。。另一个客户端
# 往频道channel发送消息
127.0.0.1:6379> publish channel message
```





#### 事务

> Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：
>
> - 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
> - 事务是一个**原子**操作：事务中的命令要么全部被执行，要么全部都不执行。
>
> 一个事务从开始到执行会经历以下三个阶段：
>
> - 开始事务。
> - 命令入队。
> - 执行事务。

```bash
# 以 MULTI 开始一个事务
redis 127.0.0.1:6379> MULTI
OK
 
redis 127.0.0.1:6379> SET book-name "Mastering C++ in 21 days"
QUEUED
 
redis 127.0.0.1:6379> GET book-name
QUEUED
 
redis 127.0.0.1:6379> SADD tag "C++" "Programming" "Mastering Series"
QUEUED
 
redis 127.0.0.1:6379> SMEMBERS tag
QUEUED
 
# 最后由 EXEC 命令触发事务
redis 127.0.0.1:6379> EXEC
1) OK
2) "Mastering C++ in 21 days"
3) (integer) 3
4) 1) "Mastering Series"
   2) "C++"
   3) "Programming"
```

它先以 **MULTI** 开始一个事务， 然后将多个命令入队到事务中， 最后由 **EXEC** 命令触发事务， 一并执行事务中的所有命令。



#### 管道

> Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。这意味着通常情况下一个请求会遵循以下步骤：
>
> - 客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。
> - 服务端处理命令，并将结果返回给客户端。
>
> Redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。
>
> 不能保证命令的顺序性，原子性。
>
> 开启了管道操作后，往返时延已经被改善得相当低。
